const { exec } = require('child_process');
const path = require('path');
const fs = require('fs');

class WhisperService {
  constructor() {
    this.whisperPath = path.join(__dirname, '../../../whisper-main/whisper.cpp/build/bin/whisper-cli');
    this.modelPath = path.join(__dirname, '../../../whisper-main/whisper.cpp/models/ggml-base.bin');
    this.validateSetup();
  }

  validateSetup() {
    if (!fs.existsSync(this.whisperPath)) {
      throw new Error('Whisper executable not found. Please follow setup instructions.');
    }
    if (!fs.existsSync(this.modelPath)) {
      throw new Error('Whisper model not found. Please download ggml-base.bin model.');
    }
  }

  async transcribe(videoPath) {
    const tempDir = path.join(__dirname, '../../temp');
    const audioPath = path.join(tempDir, `${Date.now()}_audio.wav`);
    
    try {
      // Enhanced audio extraction with proper error handling
      await this.extractAudio(videoPath, audioPath);
      const transcription = await this.runWhisper(audioPath);
      const captions = this.parseSRT(transcription);
      
      // Cleanup
      if (fs.existsSync(audioPath)) {
        fs.unlinkSync(audioPath);
      }
      
      return captions;
    } catch (error) {
      // Cleanup on error
      if (fs.existsSync(audioPath)) {
        fs.unlinkSync(audioPath);
      }
      throw error;
    }
  }

  extractAudio(videoPath, audioPath) {
    return new Promise((resolve, reject) => {
      const command = `ffmpeg -i "${videoPath}" -ar 16000 -ac 1 -c:a pcm_s16le -y "${audioPath}"`;
      
      exec(command, { timeout: 300000 }, (error, stdout, stderr) => {
        if (error) {
          reject(new Error(`Audio extraction failed: ${stderr || error.message}`));
        } else {
          resolve();
        }
      });
    });
  }

  runWhisper(audioPath) {
    return new Promise((resolve, reject) => {
      const command = `"${this.whisperPath}" -m "${this.modelPath}" -f "${audioPath}" --output-srt --language auto`;
      
      console.log('Whisper command:', command);

      exec(command, { timeout: 600000 }, (error, stdout, stderr) => {
        if (error) {
          console.log('Whisper error details:', error);
          console.log('stderr:', stderr);
          reject(new Error(`Whisper transcription failed: ${stderr || error.message}`));
        } else {
          // The whisper CLI creates an SRT file with the same name as the audio file
          const srtPath = audioPath + '.srt';
          if (fs.existsSync(srtPath)) {
            try {
              const srtContent = fs.readFileSync(srtPath, 'utf8');
              // Clean up the SRT file after reading
              fs.unlinkSync(srtPath);
              resolve(srtContent);
            } catch (readError) {
              reject(new Error(`Failed to read SRT file: ${readError.message}`));
            }
          } else {
            reject(new Error('SRT file was not generated by Whisper'));
          }
        }
      });
    });
  }

  parseSRT(srtContent) {
    if (!srtContent || typeof srtContent !== 'string') {
      return [];
    }

    const captions = [];
    const blocks = srtContent.trim().split(/\n\s*\n/);

    blocks.forEach((block, index) => {
      const lines = block.trim().split('\n');
      if (lines.length >= 3) {
        const [sequence, timestamp, ...textLines] = lines;
        const text = textLines.join(' ').trim();
        
        // Parse timestamp (format: 00:00:00,000 --> 00:00:05,000)
        const timeMatch = timestamp.match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);
        if (timeMatch && text) {
          const startTime = this.srtTimeToSeconds(timeMatch[1]);
          const endTime = this.srtTimeToSeconds(timeMatch[2]);
          
          captions.push({
            id: parseInt(sequence) || index + 1,
            start: startTime,
            end: endTime,
            text: text
          });
        }
      }
    });

    return captions;
  }

  srtTimeToSeconds(timeStr) {
    const [time, ms] = timeStr.split(',');
    const [hours, minutes, seconds] = time.split(':').map(Number);
    return hours * 3600 + minutes * 60 + seconds + ms / 1000;
  }
}

module.exports = new WhisperService();